# Вопросики (НЕТ ПОСЛЕДНИХ ТРЕХ ВОПРОСОВ ТАК КАК Я УСТАЛ ДУМАТЬ):

## Как организовать многоуровневое выпадающее меню на чистом JavaScript и какие сложности могут возникнуть при работе с вложенными подменю?

### Организация

Для организации многоуровневого выпадающего меню на чистом JavaScript
потребуется организовать определенную структуру верстки:

```html

<div class="dropdown">
    <div class="dropdown-header">Заголовок</div>
    <div class="dropdown-body">
        <div class="dropdown-list">
            <div class="dropdown-item">Первый</div>
            <div class="dropdown-item">
                <div class="dropdown">
                    <div class="dropdown-header">
                        Второй
                    </div>
                    <div class="dropdown-body">
                        <div class="dropdown-list">
                            <div class="dropdown-item">
                                Вложенный первый
                            </div>
                            <div class="dropdown-item">
                                Вложенный второй
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="dropdown-item">Третий</div>
        </div>
    </div>
</div>
```

Пример хранится в `/templates/dropdown-template.html`

Для минимальной реализации требуется `div` с классом `modal` и `div` с классом `dropdown-body`.
Внутри `dropdown-body` расположен `dropdown-list` с элементами, которые будут появляться при раскрытии блока.

Блок раскрывается засчет стилей. `dropdown-body` изначально имеет стиль `grid-template-rows: 0fr;`,
который скрывает элементы списка. Чтобы раскрыть элемент добавлен стиль при наведении которого начинают отображаться
элементы списка.

```css
.dropdown:hover > .dropdown-body {
    grid-template-rows: 1fr;
}
```

Такая реализация не требует использования JavaScript, что облегчает разраработку подобного компонента.

### Сложности

При разработке возникли сложности с вложенным выпадающем списком, так как он является дочерним элементом вложенного
списка.
Существовала проблема при которой элементы вложенного списка не соблюдали свою ширину и ограничивались шириной
родительского блока `div.modal`.
Достаточным решением этой проблемы стало добавление стиля для элемента списка `min-width: fit-content;`

## Какие методы используются для реализации адаптивного поведения меню на мобильных устройствах и чем отличается обработка событий клика и наведения на разных устройствах?

### Реализация адаптивного поведения меню на разных устройствах.

Для адаптивного поведения на мобильных устройствах используются `media`-запросы в `css`.

Пример:

```css
@media (max-width: 480px) {
// Стили
}
```

В случае использования мобильного устройства данные стили будут применяться только для устройств с разрешением меньше
480px,
что подходит для большинства мобильных экранов.

### чем отличается обработка событий клика и наведения на разных устройствах?

На десктопе и мобильных события работают по-разному.

#### Клик

На десктопе `click` срабатывает сразу. На мобильных браузерах исторически была задержка **300мс** — браузер ждал, не
будет ли двойного тапа. Сейчас она убрана если есть в `<head>`:

```html

<meta name="viewport" content="width=device-width">
```

или через CSS:

```css
touch-action: manipulation

;
```

#### Наведение (hover)

На мобильных `hover` — проблемное место. Физически навести курсор невозможно, поэтому:

- первый тап = hover
- второй тап = click

Это часто ломает UX — например, выпадающее меню по hover на мобильном требует двух нажатий. Решение — не использовать
hover для критичного функционала, только для визуального украшения:

```css
@media (hover: hover) {
    .btn:hover {
        background: red;
    }
}
```

`hover: hover` — медиазапрос, который срабатывает только на устройствах где hover реально поддерживается.

#### Touch-события

На мобильных есть отдельные события которых нет на десктопе: `touchstart`, `touchmove`, `touchend`. Они срабатывают
быстрее чем `click` и дают больше контроля (например, определить свайп). Если важна скорость отклика на мобильных —
можно слушать `touchstart` вместо `click`.

## Как можно реализовать сохранение состояния выбранного пункта меню между сессиями пользователя? Объясните, когда и почему целесообразно использовать localStorage.

### Как можно реализовать сохранение состояния выбранного пункта меню между сессиями пользователя?

Для сохранения состояний между сессиями пользователя можно использовать localStorage и хранит выбранный пункт в кеше
страницы браузера.
Для реализации использовались 2 переменные:

1. Отвечает за индекс выбранного элемента
2. Отвечает за текст выбранного элемента для отображения на странице в качестве заголовка

Для реализации достаточно двух методов:

1. `localStorage.setItem(key, value);` - сохранение в localStorage
2. `localStorage.getItem(key)` - получение из localStorage

При клике по элементу вызываем установку значения. При перезагрузке получение.

### Когда и почему целесообразно использовать localStorage?

localStorage целесообразно использоваться, когда требуется сохранить какие-то простые значения, т. е. не сложные
объекты, а что-то в образе строки,
которые не требуется хранить на сервере. Так как это сказывается на быстродействии страницы, не требуется тратить
вычислительную мощность
сервера и ждать задержу ответа с сервера.

## В чём особенности реализации модального окна с динамическим содержимым и как обеспечить его правильное закрытие в различных сценариях (по кнопке, по клику вне окна, по клавише Esc)?

### В чём особенности реализации модального окна с динамическим содержимым?

При реализации модального окна с динамическим содержимым главной особенностью является
определения какое модальное окно показать, как понять, что при клике именно на этот блок должно отобразится
именно это модальное окно.

Для определения модального окна каждому элементу, который вызывает модальное окно был добавлен `data`-атрибут:
`data-modal-id`,
который хранил в себе `id` блока модального окна. Таким образом при клике по элементу на `JavaScript` вычленяется
`id` необходимо блока, которому добавится стиль `active` для отображения.

Альтернативно можно не создавать заранее модальные окна, если окно должно появляться у элементов, которые
создаются динамически и имеют в себе какой-либо контент, необходимый отобразить в модальном окне.

Для реализации такого поведения необходимо разработать парсер для внутренних элементов блока. Данная возможность не
реализована на текущей версии сайта, так как нет динамических элементов для отображения в модальном окне.

### Как обеспечить его правильное закрытие в различных сценариях (по кнопке, по клику вне окна, по клавише Esc)?

Для обеспечения правильного закрытия достаточно при открытии модального окна добавить слушатель событий на страницу.

1. Слушатель событий по нажатию клавиши, вызывающая смену стилей у элементов при нажатии кнопки `Esc`.
2. Слушатель событий клика для элемента кнопки закрытия, вызывающая смену стилей у элементов при нажатии на кнопку.
3. Слушатель события клика для страницы, вызывающая смену стилей у элементов при нажатии за пределами модального окна.

Важно помнить, что после закрытия окна необходимо удалить слушатели событий через `removeEventListener()`, иначе
обработчик
будет срабатывать несколько раз и вызовет утечку памяти.

## Какие подходы можно использовать для валидации данных формы внутри модального окна и как сообщать пользователю об ошибках?

### Валидация форм

Существует два подхода валидации форм:

1. Нативно в `HTML`
2. При помощи `JavaScript`

#### HTML

Для валидации значений с помощью `HTML` используются свойства. Например: `required`, `minlenght`, `maxlength`
Они будут срабатывать еще до отправки формы. Браузер самостоятельно будет выводить ошибки.

#### JavaScript

Для валидации значений с помощью `JavaScript` требуется написать собственный метод, который будет проверять значения.
Это позволяет очень гибко настроить валидацию и производить дополнительную логику.

### Как сообщать пользователю об ошибках?

Если валидация реализована через `HTML`, то сообщения будут отображаться во всплывающих подсказах рядом с инпутами.

Если валидация реализована через `JavaScript`, потребуется создать блоки с сообщениями об ошибке для каждого `input`.
На форме должен быть слушатель событий, срабатывающий при отправке данных формы.

Метод проверки значений вызывается в соответствии с типом `input`. Если значение не проходит валидацию, то `input`,
который вернул неправильное значение, отображает сообщение с ошибкой.

## Опишите процесс динамической загрузки изображений в слайдер и обновления его содержимого без перезагрузки страницы.

На странице создана кнопка добавления изображения в слайдер. Кнопка имеет обработчик событий.

```js
sliderFileInput.onchange = (e) => addImage(e.target.files[0])
```

`e.target.files[0]` - файл с изображением.

В методе `addImage()` файл преобразовывается в ссылку на этот файл, чтобы указать его как `src` для изображения.

После получения ссылки на изображение в верстку слайдера при помощи метода `insertAdjacentHTML` добавляется шаблон
слайда.
Как только слайд будет добавлен в слайдер, он пересоздает миниатюры для быстрой навигации.

## Какие принципы обеспечения доступности (доступ к элементам с клавиатуры, aria-атрибуты и др.) необходимо соблюдать при реализации интерактивных элементов веб-страницы? (Можно взять еще что-то из ИИ)

### Клавиатурная навигация

Все интерактивные элементы должны быть доступны с клавиатуры. Семантические теги — button, a,
input — обеспечивают это из коробки. Для несемантических элементов, таких как div, необходимо добавлять tabindex="0" и
обработчик нажатий Enter и Space. Порядок Tab должен быть логичным и совпадать с визуальным порядком элементов на
странице.

### ARIA-атрибуты

ARIA-атрибуты применяются в тех случаях, когда семантики HTML недостаточно для описания роли или состояния элемента

```html

<div role="button" tabindex="0">Кнопка</div>
```

### Альтернативный текст изображений

Все значимые изображения должны содержать атрибут alt с описанием. Декоративные изображения должны иметь пустой alt="" —
в таком случае скринридер их пропустит
